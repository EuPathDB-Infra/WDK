/**
 * @module Store
 */
import di from 'di';
import EventEmitter from 'events';
import Dispatcher from '../Dispatcher';

/**
 * Store meta-constructor. This class will create a new class based on the
 * `spec` object provided. Any instance of the new class will register the
 * method `spec.handleDispatch` with the application dispatcher. Likewise,
 * `spec.getState` will be used to return the state of the store to subscribers
 * of the store.
 *
 * Example usage:
 *
 *     var MyStore = new Store({
 *       state: {
 *         items: []
 *       },
 *
 *       dispatchHandler(action, emitChange) {
 *         switch (action) {
 *           case ActionTypes.MY_ACTION:
 *             // do things to state.items
 *             emitChange();
 *             break;
 *         }
 *       },
 *
 *       getState() {
 *         return state;
 *       }
 *
 *     });
 *
 * @class Store
 * @constructor
 * @param {object} spec A specialization object used to customize a Store. It
 * must contain two functions: `dispatchHandler(action, emitChange, waitFor)`
 * and `getState()`.
 *
 * In `dispatchHandler`, `action` is the dispatched action,
 * `emitChange` is a function to that will call callbacks registered with
 * {{#crossLink "Store/subscribe"}}{{/crossLink}}, and `waitFor` delegates to
 * the dispatcher's `waitFor` method (see http://facebook.github.io/flux/docs/dispatcher.html#api).
 *
 * `getState` should be a function that returns the Store's state.
 */

export default class Store {
  constructor(spec) {
    ensureFunction(spec.dispatchHandler, "dispatchHandler");
    ensureFunction(spec.getState, "getState");

    // A flux store constructor that will get the application dispatcher
    // injected by the injection system. It will also call the `spec` methods
    // described above.
    var WdkStore = function WdkStore(dispatcher) {
      var specCopy = Object.create(spec);
      var emitter = new EventEmitter();

      var emitChange = function emitChange() {
        emitter.emit('change', specCopy.getState());
      };

      var waitFor = function waitFor(tokens) {
        dispatcher.waitFor(tokens);
      };

      /**
       * Token generated by the dispatcher. This can be used with the `waitFor`
       * function provided to the `dispatchHandler` function.
       * @property dispatchToken
       * @type string
       */
      var dispatchToken = dispatcher.register(action => {
        specCopy.dispatchHandler(action, emitChange, waitFor);
      });

      // Define dispatchToken as a getter so that it cannot
      // be augmented externally.
      Object.defineProperty(this, 'dispatchToken', {
        get() { return dispatchToken; }
      });

      /**
       * Register a callback function to be invoked when the Store's internal
       * state has been changed. `callback` will be called with the result of
       * {{#crossLink "Store/getState"}}{{/crossLink}}.
       *
       * @method subscribe
       * @param {function} callback
       */
      this.subscribe = function subscribe(callback) {
        emitter.on('change', callback);
      };

      /**
       * Remove a registered callback function. See
       * {{#crossLink "Store/subscribe"}}{{/crossLink}}
       *
       * @method unsubscribe
       * @param {function} callback
       */
      this.unsubscribe = function unsubscribe(callback) {
        emitter.removeListener('change', callback);
      };

      this.getState = function getState() {
        return specCopy.getState();
      };
    };

    di.annotate(WdkStore, new di.Inject(Dispatcher));

    return WdkStore;
  }
}

function ensureFunction(fn, name) {
  var message = "Store " + name + " " + fn + " is not a function";
  if (typeof fn !== 'function') throw new TypeError(message);
}
