/**
 * @module Store
 */
import EventEmitter from 'events';
import Dispatcher from '../Dispatcher';


/**
 * Used to create a Store that can handle actions dispatched on the application
 * dispatcher.
 *
 * Example usage:
 *
 *     var state = {
 *       items: []
 *     };
 *
 *     module.exports = new Store({
 *
 *       dispatchHandler(action, emitChange) {
 *         switch (action) {
 *           case ActionTypes.MY_ACTION:
 *             // do things to state.items
 *             emitChange();
 *             break;
 *         }
 *       },
 *
 *       getState() {
 *         return state;
 *       }
 *
 *     });
 *
 * This class makes use of the "revealing constructor pattern" for better encapsulation
 * (see https://blog.domenic.me/the-revealing-constructor-pattern/).
 *
 * @class Store
 * @constructor
 * @param {object} spec A specialization object used to customize a Store. It
 * must contain two functions: `dispatchHandler(action, emitChange, waitFor)`
 * and `getState()`.
 *
 * In `dispatchHandler`, `action` is the dispatched action,
 * `emitChange` is a function to that will call callbacks registered with
 * {{#crossLink "Store/subscribe"}}{{/crossLink}}, and `waitFor` delegates to
 * the dispatcher's `waitFor` method (see http://facebook.github.io/flux/docs/dispatcher.html#api).
 *
 * `getState` should be a function that returns the Store's state.
 */

export default class Store {
  constructor(spec) {
    var { dispatchHandler, getState } = spec;
    ensureFunction(dispatchHandler, "dispatchHandler");
    ensureFunction(getState, "getState");

    var emitter = new EventEmitter();

    /**
     * Token generated by the dispatcher. This can be used with the `waitFor`
     * function provided to the `dispatchHandler` function.
     * @property dispatchToken
     * @type string
     */
    var dispatchToken = Dispatcher.register(action => {
      dispatchHandler(action, function emitChange() {
        emitter.emit('change', getState());
      }, function waitFor(tokens) {
        Dispatcher.waitFor(tokens);
      });
    });

    // Define dispatchToken as a getter so that it cannot
    // be augmented externally.
    Object.defineProperty(this, 'dispatchToken', {
      get() { return dispatchToken; }
    });

    var thisSubscribe = this.subscribe;
    var thisUnsubscribe = this.unsubscribe;

    /**
     * Register a callback function to be invoked when the Store's internal
     * state has been changed. `callback` will be called with the result of
     * {{#crossLink "Store/getState"}}{{/crossLink}}.
     *
     * @method subscribe
     * @param {function} callback
     */
    this.subscribe = function(callback) {
      emitter.on('change', callback);
      thisSubscribe.apply(this, arguments);
    };

    /**
     * Remove a registered callback function. See
     * {{#crossLink "Store/subscribe"}}{{/crossLink}}
     *
     * @method unsubscribe
     * @param {function} callback
     */
    this.unsubscribe = function(callback) {
      emitter.removeListener('change', callback);
      thisUnsubscribe.apply(this, arguments);
    };

    /**
     * Get the current state of the Store.
     *
     * @method getState
     * @returns The state of the Store
     */
    this.getState = getState;
  }
}


function ensureFunction(fn, name) {
  var message = "Store " + name + " " + fn + " is not a function";
  if (typeof fn !== 'function') throw new TypeError(message);
}
