import curry from 'lodash/function/curry';

/**
 * Creates a function that returns a reducer function with the signature:
 *
 *    F<U, V> = (state: U, action: V) => U;
 *
 * When called, the reducer function will return an object whose keys match
 * the keys of the `reducers` object this function is called with.
 *
 * Consider the following reducer function created with this function:
 *
 *    let reducer = combineReducers({
 *      count: function reduceCount(count = 0, action) {
 *        // ...
 *      },
 *      color: function reduceColor(color = 'green', action) {
 *        // ...
 *      }
 *    });
 *
 * Assuming reduceCount always returns a number, and reducerColor always returns
 * a string, `reducer` defined above will alway return an Object of the
 * following type:
 *
 *    type State = { count: number; color: string; };
 *
 *
 * If a reducer function causes a part of the state to change, it is assumed
 * the reducer will return a new object. This information is used to determine
 * if `reduceState` should return a new object or the same object. This is
 * effectively immutability.
 *
 * @param {Object} reducers An Object whose property values are reducer functions.
 * @returns {Function} Returns a reducer function.
 */
export function combineReducers(reducers) {
  return function reduceState(state = {}, action) {
    return Object.keys(reducers).reduce(function(state, key) {
      let reducer = reducers[key];
      let childState = state[key];
      let newChildState = reducer(childState, action);

      return newChildState === childState ? state
           : Object.assign({}, state, {
               [key]: newChildState
             });
    }, state);
  };
}

/**
 * Creates a transform function that can be applied to an object. When called
 * with an object, it will transform that object into a new value based on the
 * spec.
 *
 * The spec an be one of the following:
 *  - string|number: Returns the associated value. This can be a string or number,
 *    so it will work with both plain objects and arrays.
 *  - Function: Applied to state. The return value is returned.
 *  - Array: Represents a key-path. The array is reduced over the state, calling
 *    `selector(arrayItem)(previousValue)` for each item.
 *  - Object: Creates an object with the same keys as the spec and values
 *    generated by applying the associated spec value as a new selector spec to
 *    `state`.
 *
 *
 * Examples
 *
 *    // single value getter with array
 *    selector([ 'people', 0 ]); //=> first person in people array
 *
 *    // single value getter with a transform function
 *    let isHappy = filter(p => p.isHappy) //=> returns a filter transform
 *
 *    // filter(p => p.isHappy) is equivalent to:
 *    function isHappy(people) {
 *      return people.filter(function(person) {
 *        return person.isHappy;
 *      });
 *    }
 *    selector([ 'people', isHappy ]); //=> people that are happy
 *
 *    // new object
 *    selector({
 *      firstPerson: [ 'people', 0 ]
 *    }); //=> { firstPerson: ... }
 *
 *    selector({
 *      top: {
 *        middle: {
 *          personOfInterest: [ 'people', people => people.find(isOfInterest) ]
 *        }
 *      }
 *    }); // => { top: { middle: { personOfInterest } } }
 */
export function selector(spec) {
  return function transform(state) {
    if (state === undefined) return;

    if (typeof spec === 'string' || typeof spec === 'number') {
      return state[spec];
    }

    if (typeof spec === 'function') {
      return spec(state);
    }

    if (Array.isArray(spec)) {
      return spec.reduce(function(value, specItem) {
        return selector(specItem)(value);
      }, state);
    }

    return Object.keys(spec).reduce(function(projection, key) {
      projection[key] = selector(spec[key])(state);
      return projection;
    }, {});
  };
};
