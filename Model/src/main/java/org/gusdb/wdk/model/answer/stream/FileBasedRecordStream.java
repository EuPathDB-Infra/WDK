package org.gusdb.wdk.model.answer.stream;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.gusdb.wdk.model.WdkModelException;
import org.gusdb.wdk.model.answer.AnswerValue;
import org.gusdb.wdk.model.record.RecordInstance;
import org.gusdb.wdk.model.record.TableField;
import org.gusdb.wdk.model.record.attribute.AttributeField;

public class FileBasedRecordStream implements Iterable<RecordInstance>, AutoCloseable {

  private final AnswerValue _answerValue;
  private final Path _fileRepository;
  private final Set<AttributeField> _attributes;
  private final Set<TableField> _tables;
  private final List<FileBasedRecordIterator> _iterators = new ArrayList<>();
  private boolean _filesPopulated = false;

  /**
   * Creates a record stream that can provide all records without paging by
   * caching attribute and table query results in files and then reading
   * from those file in parallel to construct RecordInstance objects one by
   * one as requested by the provided iterator.
   * 
   * @param answerValue answer value defining the records to be returned
   * @param fileRepository file repository where temporary files will be written
   * @param attributes 
   * @param tables
   */
  public FileBasedRecordStream(
      AnswerValue answerValue,
      Path fileRepository,
      Set<AttributeField> attributes,
      Set<TableField> tables) {
    _answerValue = answerValue;
    _fileRepository = fileRepository;
    _attributes = attributes;
    _tables = tables;
  }

  /**
   * Serially executes all attribute and table queries required to construct
   * RecordInstance objects based on the attribute and table sets requested
   * in the constructor.  Handles opening and closing DB connections, serializing
   * results to files, and closing files.
   * 
   * @throws WdkModelException if unable to complete population
   */
  public void populateFiles() throws WdkModelException {
    // TODO: implement
    _filesPopulated = true;
  }

  /**
   * Creates an iterator which can construct RecordInstance records on the fly
   * from the files produced by populateFiles().  Please note that the RecordInstances
   * returned by the iterator will ONLY have the fields and attributes specified in
   * this class's constructor; additional fields and attributes cannot be added at-will.
   */
  @Override
  public Iterator<RecordInstance> iterator() {
    if (!_filesPopulated) {
      throw new IllegalStateException("Iterators are not available from this class until files are populated.");
    }
    FileBasedRecordIterator iter = new FileBasedRecordIterator(
        /* TODO: decide what args this needs- maybe a map from Fields to files or something? */);
    _iterators.add(iter);
    return iter;
  }

  /**
   * Closes and removes all files written by this object and alerts any
   * returned iterators that files will no longer be available.  Files will
   * be closed quietly
   */
  @Override
  public void close() {
    _filesPopulated = false;
    for (FileBasedRecordIterator iter : _iterators) {
      iter.close();
    }
    // TODO: remove files generated by this instance
  }
}
