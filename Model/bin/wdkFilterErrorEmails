#!/usr/bin/perl

use strict;
use Getopt::Long;
use JSON;

my ($startDate, $endDate, $report, $emailsFile, $singleFilter, $filtersFile);

&GetOptions('sd=s' => \$startDate,
            'ed=s' => \$endDate,
            'r!' =>  \$report,
            'ef=s' => \$emailsFile,
            'sf=s' => \$singleFilter,
            'ff=s' => \$filtersFile,
            );

usage() unless ($emailsFile && ($filtersFile || $singleFilter) && !($filtersFile && $singleFilter) && !($singleFilter && $report));

my $emailDelim = "##ERROR_END##";

my @filtersAsStrings; # to preserve input order
my %filtersInfo; # key is filterAsString, value is hash ref w/ info about the filter
my ($startM, $startD, $startY, $endM, $endD, $endY) = parseStartEndDates($startDate, $endDate);

#
# parse filters
#
if ($singleFilter) {
  &parseFilterLine($singleFilter, \@filtersAsStrings, \%filtersInfo);
}

else {
  open(FF, $filtersFile) || die "Can't open filters file '$filtersFile'\n";
  my $jsonString = "";
  while(<FF>) {
    $jsonString .= $_;
  }
  &parseFilterJson($jsonString, \@filtersAsStrings, \%filtersInfo);
}

#
# scan emails file, apply filters, and output appropriate emails
#
open(F, $emailsFile) || die "Can't open emails file '$emailsFile'\n";
my @currentEmail;
my $currentDate;
my $totalEmails;
my $matchedEmails;
while(<F>) {
  if (/$emailDelim/) {
    if (&dateFilter($currentDate)) {
      $totalEmails++;
      $matchedEmails += &handleEmail(\@currentEmail, \@filtersAsStrings, \%filtersInfo, $emailDelim, $singleFilter, $report);
    }
    @currentEmail = ();
  }
  else {
    $currentDate = $1 if (/Date: (\d+\/\d+\/\d+)/);
    push(@currentEmail, $_);
  }
}
close(F);

#
# optionally, print report
#
if ($report) {
  foreach my $filterAsString (@filtersAsStrings) {
    print STDOUT $filtersInfo{$filterAsString}->{count} . "\t" . $filtersInfo{$filterAsString}->{orig} . "\n";
  }

  my $unmatchedEmails = $totalEmails - $matchedEmails;
  print "
Total emails in date range: $totalEmails
                 # matched: $matchedEmails
               # unmatched: $unmatchedEmails
";
}

##########################################################################################

sub parseStartEndDates {
  my ($startDate, $endDate) = @_;

  my ($startM, $startD, $startY, $endM, $endD, $endY);

  if ($startDate) {
    die "Invalid start date '$startDate'.  Must be in m/d/yyyy format\n" unless $startDate =~ /(\d+)\/(\d+)\/(\d\d\d\d)/;
    ($startM, $startD, $startY) = ($1, $2, $3);
  }
  if ($endDate) {
    die "Invalid end date '$endDate'.  Must be in m/d/yyyy format\n" unless $endDate =~ /(\d+)\/(\d+)\/(\d\d\d\d)/;
    ($endM, $endD, $endY) = ($1, $2, $3);
  }
  return ($startM, $startD, $startY, $endM, $endD, $endY);
}

sub parseFilterLine {
  my ($filterLine, $filtersAsStringsRef, $filtersInfoRef) = @_;

  chomp($filterLine);
  next unless $filterLine;
  my @row = split(/\t/, $filterLine);
  my $filterAsString = $row[0];
  push(@$filtersAsStringsRef, $filterAsString);

  # each filter can have more than one string to match, separated by &&
  my @filterTerms = split(/\s+\&\&\s+/, $filterAsString);

  $filtersInfoRef->{$filterAsString} = {orig => $filterLine, terms => \@filterTerms, count => 0};
}

sub parseFilterJson {
  my ($filterJsonStr, $filtersAsStringsRef, $filtersInfoRef) = @_;
  my $filtersArray = decode_json($filterJsonStr);
  foreach my $category (@$filtersArray) {
    my $matchStrings = $category->{'matchStrings'};
    my $joinedMatchString = join(' && ', @$matchStrings);
    push(@$filtersAsStringsRef, $joinedMatchString);
    $filtersInfoRef->{$joinedMatchString} = {orig => $joinedMatchString, terms => \@$matchStrings, count => 0};
  }
}

sub dateFilter {
  my ($date) = @_;

  $date =~ /(\d+)\/(\d+)\/(\d+)/;
  my ($y, $m, $d) = ($1, $2, $3);

  # note: these comparisons are imperfect and will fail around year boundaries
  return 0 if ($startDate && ($y < $startY || $m < $startM || $d < $startD));
  return 0 if ($endDate && ($y > $endY || $m > $endM || $d > $endD));

  return 1;
}

sub handleEmail {
  my ($emailArray, $filtersAsStringsRef, $filtersInfoRef, $emailDelim, $printIfMatch, $report) = @_;

  my $matched;
  foreach my $filterAsString (@$filtersAsStringsRef) {
    my $filterInfo = $filtersInfoRef->{$filterAsString};
    $matched = matchesFilter($filterInfo->{terms}, $emailArray);
    if ($matched) {
      $filterInfo->{count} += 1 ;
      last;
    }
  }

  if (!$report && (($printIfMatch && $matched) || (!$printIfMatch && !$matched)))  {
    print STDOUT join("", @$emailArray) . $emailDelim . "\n";
  }
  return $matched;
}

sub matchesFilter {
  my ($filterTerms, $emailArray) = @_;

  my $matched = 1;
  foreach my $filterTerm (@$filterTerms) {
    my $matchedTerm = 0;
    foreach my $emailLine (@$emailArray) {
      if (index($emailLine, $filterTerm) != -1) {
        $matchedTerm = 1;
        last;
      }
    }
    $matched &= $matchedTerm;
  }
  return $matched;
}

sub usage {
  die "
Filter a file of wdk error emails.

There are three modes of use:
  1) filter hunting.  Provide a filters file.  Output is mails that match no filter, so you can create new filters (to add to the filters file).
  2) reporting.  Provide a filters file.  Output is a report showing counts of each filter, so you can decide which filter issue to debug
  3) single filter.  Provide a single filter.  Output is mails that match that filter, so you can start debugging.

Usage: wdkFilterErrorEmails --ef emails_file <--sf single_filter | --ff filter_file> [--r] [--sd start_date] [--ed end_date]

Where:
  emails_file:     file containing wdk error emails
  single_filter:   string to use as a filter
  filter_file:     file containing one or more filters (see below for format)
  --r:             write a report to stdout
  start_date:      date in mm/dd/yyyy format.  Exclude emails before this date.
  end_date:        date in mm/dd/yyyy format. Exclude emails after this date

Filters file format: tab delimited, with first column being on or more filters (delimited by \&\&).  Other columns are ignored.  Lines beginning with # are ignored.

Filters are applied in the order found in the file.  Only the first matching filter is effective.

";
}
